-- Author: 1332491
-- Created on: 12/6/2017 2:25:12 PM
{-# LANGUAGE LambdaCase, GeneralizedNewtypeDeriving, RecordWildCards #-}
module Cortex.Concurrent.Aquila.InstanceManager.JobDataManager
    ( JobDataManagerConfig(..), defJDMConfig, defServerConfigEx
    , Config(..), ConfigEx(..)
    , allocateChild
    , fetch, closure, task, exit
    , main, start
    ) where

import Cortex.Concurrent.Aquila.Utils
import Cortex.Concurrent.Aquila.Types
import Cortex.Data.HTTP.Persistent
import Cortex.Data.HTTP.Server
import Cortex.Data.HTTP.Spawn.Client
import Cortex.Data.HTTP.Spawn.Lite
import Cortex.Data.HTTP.Spawn.Types
import Cortex.Stem.Array(valueAnyIArray)
import qualified Cortex.Concurrent.Aquila.JobManager.Client as JM
import qualified Cortex.Data.HTTP.Mu as HTTP
import qualified Cortex.Data.HTTP.Server.Config as Server
import qualified Cortex.Stem.Core as Core
import qualified Cortex.Stem.Stream.Mu as Stream

import Control.Concurrent
import Control.Concurrent.MVar
import Control.Exception
import Control.Monad
import Data.Default
import System.Console.CmdArgs.Explicit

data JobDataManagerConfig = JobDataManagerConfig
    { serverConfigEx :: ConfigEx
    , instanceManagerPort :: InstancePort
    , instanceManagerId   :: InstanceManagerId
    , nJDMs               :: Int
    }
    deriving (Show)

instance Default JobDataManagerConfig where
    def = defJDMConfig (JobDataManagerPort 42000) 128

defJDMConfig :: JobDataManagerPort -> Int -> JobDataManagerConfig
defJDMConfig jdmPort nJDMs = JobDataManagerConfig
    { serverConfigEx = defServerConfigEx jdmPort nJDMs
    , instanceManagerPort = InstancePort 32200 -- FIXME centralize default ports
    , instanceManagerId = InstanceManagerId ""
    , .. }

defServerConfigEx :: JobDataManagerPort -> Int -> ConfigEx
defServerConfigEx jdmPort nJDMs = def
    { maxChildren = nJDMs
    , childThreads = 1024
    , config =  def
        { safe = False
        , nThreads = 1024
        , backlog = Just 1024
        , maxQueued = Just 1024
        , port = unJobDataManagerPort jdmPort
        , reuseAddr = False
        , title = __MODULE__
        , core = POCO
        , keepAliveConfig = Just Server.KeepAlive
            { keepAliveTimeout = 1 * 60 -- 1 minute
            , keepAliveRequests = 0     -- infinity
            }
        }
    }

flags :: [Flag JobDataManagerConfig]
flags =
    [ flagReq ["instance-manager-id"]
        (\s x -> Right (x{instanceManagerId=InstanceManagerId s}))
        "STRING" "Instance Manager Id"
    , flagReq ["instance-port"]
        (\s x -> Right (x{ instanceManagerPort = InstancePort (read s)}))
        "PORT" "Instance port number"
    ]

heartbeat :: InstancePort -> InstanceManagerId -> IO ()
heartbeat instancePort imid = void $ forkIO $ forever
    $ backoff True 2 2.0 10.0 (verifyIMId instancePort imid) >>= \case
        Left e -> do
            putStrTs $ unwords ["JDM heartbeat failed:", e ]
            Core.exit 0
        Right () -> do
            threadDelay (5 * 1000 * 1000)
            return ()

main :: IO ()
main = liteServerMain __MODULE__ (serverConfigEx def) jobDataHandler flags

start :: JobDataManagerConfig -> IO Server
start jdmCfg@JobDataManagerConfig{..} = do
    heartbeat instanceManagerPort instanceManagerId
    liteServer __MODULE__ serverConfigEx jobDataHandler jdmCfg

unpackTasks = Stream.unstreamValueByteString . unWrappedTaskArray
unpackClosure = Stream.unstreamValueByteString . unWrappedClosure

jobDataHandler :: JobDataManagerConfig
               -> SessionToken -> String -> Int
               -> IO (Handler ())
jobDataHandler cfg@JobDataManagerConfig{..} token user myPort = do
    usedVer <- io Core.version
    putStrTs $ unwords [ "JobDataManager started on port", show myPort
                       , "with config:", show cfg
                       , "using Cortex version", usedVer ]

    inUse <- newMVar False
    serverJobId <- newEmptyMVar
    jobData <- newEmptyMVar
    tasks <- newEmptyMVar
    myAddr <- io Core.getIPAddress

    heartbeat instanceManagerPort instanceManagerId

    let useOnce newJobId = modifyMVar_ inUse $ \inUse -> do
            when inUse $ printThenFail $ unwords
                [ "jobid", unJobId newJobId
                , "JDM", show myPort, "is in use" ]
            return True

        gotJobData jd = do
            putMVar jobData jd
            putMVar tasks $ unpackTasks (snd jd)

        gotJDM newJobId jdm = do
            putStrTs $ unwords
                [ "jobid", unJobId newJobId
                , "JDM", show myPort
                , "is fetching from", show jdm ]
            either (const Nothing) (const $ Just ())
                <$> try (jdmJobData myAddr jdm newJobId >>= gotJobData)

        gotJDMs jobHost jobPort newJobId jdms
            = firstJustM (gotJDM newJobId) jdms'
                >>= maybe (printThenFail $ unwords
                            [ "jobid", unJobId newJobId
                            , "JDM", show myPort
                            , "failed to download job data from"
                            , show jdms' ])
                          (const $ return ())
            where
            jdms' = jdms
                    ++ [(JobDataManagerHost (unJobHost jobHost)
                        ,JobDataManagerPort (unJobPort jobPort))]

    return $ do
        "fetch" $/ postValue
                $ \_ (FetchJobData (jobHost, jobPort, newJobId)) -> do

                    useOnce newJobId

                    putStrTs $ unwords
                        [ "jobid", unJobId newJobId
                        , "JDM", show myPort, "is fetching job data"]

                    putMVar serverJobId newJobId

                    -- If "fetch" fails IM will kill this JDM
                    either (gotJDMs jobHost jobPort newJobId)
                           (gotJobData)
                        =<< JM.jdms (jobHost, jobPort)
                                newJobId instanceManagerId
                                ( JobDataManagerHost myAddr
                                , JobDataManagerPort myPort)

                    return $ responseObject $ toAny ()

        "closure" $/ GET $. \r -> do
            serverJobId <- readMVar serverJobId
            case r ?& "jobid" of
                Just jobId -> if JobId jobId == serverJobId
                    then responseObject . toAny . fst <$> readMVar jobData
                    else printThenFail $ unwords
                            [ "JDM", show myPort, "is expecting jobid"
                            , unJobId serverJobId, "got:", jobId ]
                _ -> printThenFail
                        "JobDataManager: missing jobid argument in closure request"

        "task" $/ GET $. \r -> do
            serverJobId <- readMVar serverJobId
            case (r ?& "jobid", r?& "taskid") of
                (Just jobId, Just taskId) -> if JobId jobId == serverJobId
                    then responseObject . toAny
                            . flip valueAnyIArray (read taskId)
                            <$> readMVar tasks
                    else printThenFail $ unwords
                            [ "JDM", show myPort, "is expecting jobid"
                            , unJobId serverJobId
                            , "got:", jobId ]
                _ -> printThenFail
                        "JobDataManager: missing arguments in task request"

        "jobdata" $/ GET $. \r -> do
            serverJobId <- readMVar serverJobId
            case r ?& "jobid" of
                Just jobId -> if JobId jobId == serverJobId
                    then do
                        -- FIXME put this under debug flag
                        -- when (debug >= DebugNormal) $ do
                        putStrTs $ unwords
                            [ "jobid", unJobId serverJobId
                            , "JDM", show myPort, "is serving job data" ]
                        responseObject . toAny <$> readMVar jobData
                    else printThenFail $ unwords
                            [ "JobDataManager: expecting jobid"
                            , unJobId serverJobId, "got:", jobId ]
                _ -> printThenFail "JobDataManager: missing jobid argument\
                                   \ in jobdata request"


-- Client

newtype FetchJobData = FetchJobData (JobHost, JobPort, JobId)
    deriving (HasType)

fetch :: JobDataManagerPort -> JobHost -> JobPort -> JobId -> IO ()
fetch jdPort jobHost jobPort jobId = do
    handle <- io clientHandle
    post handle url (FetchJobData (jobHost, jobPort, jobId)) [] opts
    where
    opts = noproxy |+| TimeOut (30 * 60) |+| KeepAlive False
    url = mconcat
            [ "http://127.0.0.1:", show (unJobDataManagerPort jdPort)
            , "/fetch" ]

closure :: JobDataManagerPort -> JobId -> IO (Object IFunction)
closure jdPort jobId = do
    handle <- io clientHandle
    unpackClosure <$> get handle url [] opts
    where
    opts = noproxy |+| TimeOut (30 * 60) |+| KeepAlive False
    url = mconcat
            [ "http://127.0.0.1:", show (unJobDataManagerPort jdPort)
            , "/closure"
            , "?jobid=", unJobId jobId ]

task :: JobDataManagerPort -> JobId -> TaskId -> IO (Object IAny)
task jdPort jobId taskId = do
    handle <- io clientHandle
    get handle url [] opts
    where
    opts = noproxy |+| TimeOut (30 * 60) |+| KeepAlive False
    url = mconcat
            [ "http://127.0.0.1:", show (unJobDataManagerPort jdPort)
            , "/task"
            , "?jobid=", unJobId jobId
            , "&taskid=", show (unTaskId taskId) ]

exit :: JobDataManagerPort  -> IO ()
exit jdPort = void $ try $ io
    $ HTTP.http [HTTP.proxy "", HTTP.timeout 300] HTTP.GET
        ("http://127.0.0.1:" & show (unJobDataManagerPort jdPort) & "/exit") ""

verifyIMId
    :: InstancePort
    -> InstanceManagerId
    -> IO ()
verifyIMId instancePort imid = do
    handle <- io clientHandle
    get handle url [] opts
    where
    opts = noproxy |+| TimeOut (1 * 60) |+| KeepAlive False
    url = mconcat [ "http://127.0.0.1:", show instancePort
                  , "/imid?"
                  , "imid=" & unInstanceManagerId imid
                  ]

jdmJobData :: String
           -> (JobDataManagerHost, JobDataManagerPort)
           -> JobId
           -> IO (WrappedClosure, WrappedTaskArray)
jdmJobData myAddr (host, port) jobId = do
    handle <- io clientHandle
    get handle url [] opts
    where
    opts = noproxy |+| TimeOut (2 * 60) |+| KeepAlive False
    url = mconcat [ "http://", unJobDataManagerHost host
                  , ":", show (unJobDataManagerPort port)
                  , "/jobdata"
                  , "?jobid=" & unJobId jobId
                  , "&inst=" & myAddr ]
