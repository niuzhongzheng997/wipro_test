{-# LANGUAGE RecordWildCards #-}
-- Author: 1297892
-- Created on: 3/29/2016 6:32:35 PM
module Cortex.Concurrent.Aquila.Trail
    ( Server.Config(..)
    , Server.Verbosity(..)
    , Settings(..)
    , Options(..)
    , start
    , startServer
    , main
    ) where

import Cortex.Data.HTTP.Server as Server
import Cortex.Data.HTTP.Persistent as HTTP
import Cortex.Concurrent.Aquila.Trail.Context
import Cortex.Concurrent.Aquila.Trail.Database as Database
import Cortex.Concurrent.Aquila.Trail.System as Sys
import Cortex.Concurrent.Aquila.Utils as Utils
import qualified Cortex.Data.DB.Connect as Connect
import qualified Cortex.Stem.Stream as Stream
import Cortex.Stem.Thread.Mu(sleep)
import System.Console.CmdArgs.Explicit
import System.Console.CmdArgs.Text
import Control.Arrow
import Control.Monad
import Data.Default

data Settings = Settings
    { createDatabase :: Bool
    , sysSettings    :: Sys.SystemSettings
    } deriving (Show)

instance Default Settings where
    def = Settings def def

flags :: (String, String, [Flag Settings])
flags = (,,) "Settings" "Aquila Trail Settings"
    [ flagNone ["create-database"] (\x -> x{createDatabase=True}) "create the database before starting"
    , flagReq ["dist-manager"] (\s x -> Right(x{sysSettings=def{Sys.distManager=Just (Utils.hostPortPair s)}}))
        "HOST:PORT" "Aquila dist manager host:port"
    ]

data Options = Options
    { serverOptions         :: Server.Config
    , connectOptions        :: Connect.Options
    , settings              :: Settings
    } deriving (Show)

instance Default Options where
    def = Options
        { serverOptions = def { title = __MODULE__, nThreads = 256, backlog = Just 256, maxQueued = Just 256, port = 2907, safe = False, core = POCO, keepAliveConfig = Nothing }
        , connectOptions = def
            { Connect.dbms = Just Connect.PostgreSQL
            , Connect.db = Just $ "Aquila.Trail." & show schemaVersion
            }
        , settings = def
        }
        -- NOTE: nThreads: POCO uses a threadpool, nThreads is the maximum size of the pool

getOptions :: IO Options
getOptions = do
    (help,rest) <- processArgs optMode
    case help of
        Just (a,b) -> do
            putStrLn $ showText b $ helpText a optMode
            error "--help specified"    -- FIXME: better to terminate quitely
        Nothing -> injectConnection rest
  where
    injectConnection :: Options -> IO Options
    injectConnection opts = do
        let ss = settings opts
            sy = sysSettings ss
        case Sys.distManager sy of
          Just{} -> do
              h <- io HTTP.clientHandle
              return opts{ settings = ss{ sysSettings = sy
                                            { Sys.handle = Just h }}}
          Nothing -> return opts

optMode :: Mode (Maybe (HelpFormat, TextFormat), Options)
optMode = (mode "Aquila.Trail" (def,opt) "Run Aquila Trail Server" (flagArg (\v x -> error "no direct arguments permitted") "") [])
            {modeGroupFlags=Group [flagHelpFormat (\a b (_,x) -> (Just (a,b),x))] [] $ map (second $ map remapSecond) gs
            ,modeHelpSuffix=[]}
    where gs = [ f Server.configFlags serverOptions (\v x -> v{serverOptions=x})
               , f Connect.flags connectOptions (\v x -> v{connectOptions=x})
               , f flags settings (\v x -> v{settings=x})
               ]
          opt = def

f :: (String,String,[Flag a]) -> (Options -> a) -> (Options -> a -> Options) -> (String, [Flag Options])
f (name,desc,fs) proj embed = (name & ": " & desc, [remap (embed def) (proj &&& embed) x | x <- fs])

remapSecond :: (Default b, Remap m) => m a -> m (b, a)
remapSecond = remap (def,) (\(h,x) -> (x,(h,)))

start' :: (Config -> Handler () -> IO a) -> Connect.Options -> Server.Config -> Settings -> IO a
start' run connectOptions serverOptions Settings{..} = do
    ctx <- context connectOptions
    Database.create connectOptions createDatabase
    setLastEvent ctx =<< io (Database.lastTimeStamp =<< Connect.connect connectOptions)
    run serverOptions $ do
        Database.handler sysSettings ctx

-- | Start server with options in a separate thread.
startServer :: Connect.Options -> Server.Config -> Settings -> IO Server.Server
startServer = start' runServer

-- | Start server with options in a separate thread. Returns server stop action.
start :: Connect.Options -> Server.Config -> Settings -> IO (Int, IO ())
start opts cfg stgs = do
    srv <- startServer opts cfg stgs
    port <- boundPort srv
    let stop = do
            putStrLn $ unwords ["Stopping server at port", show port]
            stopServer srv
            waitForServer srv
    return (port, stop)

main :: IO ()
main = do
    Options{..} <- getOptions
    connectOptions' <- case Connect.dbTrace connectOptions of
        Connect.LogFile fn -> do
            s <- Stream.fileCreate fn
            return $ connectOptions { Connect.dbTrace = Connect.Stream s }
        _ -> return connectOptions
    (port, stop) <- start connectOptions' serverOptions settings
    putStrLn $ unwords ["Started server at port", show port]
    () <- forever $ do io (sleep 10); return ()
    -- 'stop' is what keeps the server alive here by ensuring there is a reference pointing to it
    stop `seq` return ()
