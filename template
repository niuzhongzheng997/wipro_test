{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase, NamedFieldPuns, RecordWildCards #-}
{-# OPTIONS_MU --Wall #-}
module Cortex.Risk.Broker.Async.Server(main) where

import Control.Alternative
import Control.Arrow
import Control.Concurrent
import Control.Concurrent.Cache
import Control.Concurrent.MVar
import Control.Concurrent.QSem
import Control.Exception
import Control.Monad
import Data.Either
import Data.IORef
import Data.Maybe
import System.Console.CmdArgs.Explicit

import Cortex.Concurrent.Aquila.Provision.Trail
import Cortex.Concurrent.Aquila.Provision.Autopilot(moreRecentLimit, lessRecentLimit)
import qualified Cortex.Concurrent.Aquila.JobManager.Client as JobManager
import qualified Cortex.Concurrent.Aquila.Trail.Client as Trail
import qualified Cortex.Concurrent.Aquila.Trail.Capacity as Trail
import Cortex.Concurrent.Aquila.Utils
import Cortex.Data.HTTP.Server
import Cortex.Data.HTTP.Server.Config as Config
import Cortex.Risk.Broker.Async.Protocol
import Cortex.Risk.Broker.Async.Types
import Cortex.Risk.Broker.MultiAquila as Multi hiding (Options)
import Cortex.Risk.Process.StrategyType
import Cortex.Stem.Core.BinDir(binDir)
import Cortex.Stem.Par.Async
import Cortex.Stem.Process.Mu
import qualified Cortex.Data.String.URL as URL
import qualified Cortex.Data.Version as Version
import qualified Cortex.Stem.Core as Core
import qualified Cortex.Stem.Dict.Mu2 as Dict
import qualified Cortex.Stem.Relation.Typed as R
import qualified Cortex.Stem.SafeIO as SafeIO
import qualified Cortex.Temporal.Date.Mu as Date
import qualified Cortex.Utils.Time as Time
import Strat.Data.Module

flags :: [Flag Options]
flags =
    [ flagReq ["max-submissions"] (\s x -> Right x{maxSubmissions=read s})
      "INT" "Maximum number of concurrent job submissions"
    , flagReq ["aquila"] (\s x -> Right x{aquilaJobMan = Just $ f s})
      "HOST:PORT" "Aquila job manager"
    , flagReq ["on-prem-jm"] (\s x -> Right x{onPremJobMan = Just $ f s})
      "HOST:PORT" "On-prem job manager (for small jobs)"
    , flagReq ["on-prem-trail"] (\s x -> Right x{onPremTrail = Just $ f s})
      "HOST:PORT" "On-prem trail server (for small jobs)"
    , flagReq ["on-prem-limit"] (\s x -> Right x{smallLimit=read s})
      "INT" "On-prem small job limit."
    , flagReq ["multi-aquila"] (\s x -> Right x{multiAquilaDBName=Just s})
      "STRING" "Name of the multi-Aquila database"
    , flagReq ["multithread-aquila"]
        (\s x -> Right x{multithreadedAquilaInstanceNames =
                                multithreadedAquilaInstanceNames x ++ [s]})
        "STRING" "Name of the Aquila instance to run multithreaded pricer"
    , flagReq ["expiry-limit"] (\s x -> Right x{expiryLimit=read s})
      "INT" "Expiry limit, in seconds."
    , flagReq ["entitlement-check"] (\s x -> Right x{entitlementCheck=Just s})
      "STRING" "Check for this EMS2 subject under entity AWS"
    ] where f s = (h, p) where URL.HostPort h p = URL.readHostPort Nothing s

serverConfig :: Config
serverConfig = def
    { title = __MODULE__
    , nThreads = 1024
    , Config.port = 2910
    , reuseAddr = True
    , safe = False
    , core = POCO
    , keepAliveConfig = Just KeepAlive
                        { keepAliveTimeout = 15 * 60 -- 15 minute
                        , keepAliveRequests = 0      -- no limit
                        }
    , backlog = Just 1024
    , maxQueued = Just 1024
    }

startServer :: Config -> Options -> IO Server
startServer cfg opts = do
  print cfg
  print opts
  ctx <- mkContext opts
  runHouseKeeping opts ctx
  runLivenessCheck opts ctx
  runServer cfg $ do
    handler opts ctx

main :: IO ()
main = serverMain startServer __MODULE__ serverConfig flags

handler :: Options -> Context -> Handler ()
handler opts ctx = "call" $/ do
  methodIO $ \(SubmitV0 job) -> submitJob opts ctx job
  methodIO $ \(CollectV0 hdl) -> collectResults ctx hdl
  methodIO $ \(CloseV0 hdl) -> closeInflight ctx hdl
  methodIO $ \(PingV0 _) ->
             do accept <- readIORef (acceptingConnections ctx)
                alive  <- readIORef (serverAlive ctx)
                if accept && alive then pingVersion ctx
                         else do putStrTs "PingV0 whilst submission disabled"
                                 fail "Submission disabled"
  methodIO $ \(PingV1 _) ->
             do accept <- readIORef (acceptingConnections ctx)
                alive  <- readIORef (serverAlive ctx)
                if accept && alive then fmap Just (pingVersion ctx)
                         else do putStrTs "PingV1 whilst submission disabled"
                                 return Nothing
  authoriseJWT (Just ["1341796"]) $ \_-> methodIO
           $ \(DisableConnectionV0 _) ->
                          do alive <- readIORef (acceptingConnections ctx)
                             putStrTs "Disabling new connections"
                             atomicModifyIORef_ (acceptingConnections ctx)
                                                (const False)
                             return alive
  authoriseJWT (Just ["1341796"]) $ \_-> methodIO
           $ \(ReenableConnectionV0 _) ->
                          do alive <- readIORef (acceptingConnections ctx)
                             putStrTs "Re-enabling new connections"
                             atomicModifyIORef_ (acceptingConnections ctx)
                                                (const True)
                             return (not alive)
  method   $ \(InfoManagerAddressV0 _) -> aquilaJobMan opts

-----------------------------------------------------------

data InflightJob = InflightJob
  { lastSeen :: Datetime
  , jobCollector :: Either (Future AsyncCollector) AsyncCollector
  } deriving (HasType)

newtype InflightSubmissions = InflightSubmissions
  (IORef (Dict String (MVar (Maybe InflightJob))))
  -- (Maybe InflightJob) so we can explicitly mark jobs that have expired,
  -- to prevent race between houseKeeping and other activities.

newInflightSubmissions :: IO InflightSubmissions
newInflightSubmissions = InflightSubmissions <$> newIORef Dict.empty

addJob :: InflightSubmissions -> InflightJobHandle -> InflightJob -> IO ()
addJob (InflightSubmissions d) hdl job = do
  job' <- newMVar (Just job)
  atomicModifyIORef_ d (Dict.insert (unInflightJobHandle hdl) job')

removeJob :: InflightSubmissions -> InflightJobHandle -> IO ()
removeJob (InflightSubmissions d) hdl =
  atomicModifyIORef_ d (Dict.delete (unInflightJobHandle hdl))

lookupJob :: InflightSubmissions
          -> InflightJobHandle
          -> IO (Maybe (MVar (Maybe InflightJob)))
lookupJob (InflightSubmissions d) hdl =
  atomicModifyIORef d (id &&& Dict.lookup (unInflightJobHandle hdl))

listJobs :: InflightSubmissions
         -> IO [(InflightJobHandle, MVar (Maybe InflightJob))]
listJobs (InflightSubmissions d) =
  atomicModifyIORef d (id &&& map (first InflightJobHandle) . Dict.toList)

data TaskCount = TaskCount
    { tc_activeGrids :: Cache () (R.Rel Grids)
    , tc_pendingTasks :: Cache (String, Int) Int
    }

newTaskCount :: Options -> SafeIO TaskCount
newTaskCount opts = do
    let ttl = 2 * 60 -- refresh caches after 2 munites
    tc_activeGrids <- newCache ttl $ \() -> case multiAquilaDBName opts of
        Just ma -> do
            dbc <- Multi.dbConnect (Multi.dbOptions ma)
            fmap eitherToMaybe $ SafeIO.catch $ activeGrids dbc
        Nothing -> return $ Just R.emptyR
    tc_pendingTasks <- newCache ttl
        $ \(h, p) -> fmap (fmap nPendingTasks . eitherToMaybe)
            $ SafeIO.catch
            $ runningStats h p moreRecentLimit lessRecentLimit
    return TaskCount{tc_activeGrids, tc_pendingTasks}

gridTaskCount :: TaskCount -> SafeIO (R.Rel GridTaskCount)
gridTaskCount TaskCount{..} = do
    grids <- fromMaybe R.emptyR <$> askCache tc_activeGrids ()
    R.projectT <$> R.extendM pendingTaskCount
        (:: R.Sorting '[R.Ascend (R.NameOf CGridIPAddr)])
        grids
    where
    pendingTaskCount
        ( R.Field h :: R.FieldName (R.NameOf CGridIPAddr)
        , R.Field p :: R.FieldName (R.NameOf CGridTrail))
        = do
            tc <- fromMaybe maxBound <$> askCache tc_pendingTasks (h, p)
            return (R.Field tc :: R.FieldName (R.NameOf CGridTaskCount))

atomicModifyIORef_ :: IORef a -> (a -> a) -> IO ()
atomicModifyIORef_ ref f = atomicModifyIORef ref ((,()) . f)

modifyMVarNonAtomically_ :: MVar a -> (a -> IO a) -> IO ()
modifyMVarNonAtomically_ mv f = modifyMVarNonAtomically mv (fmap (,()) . f)

tryModifyMVarNonAtomically :: MVar a -> (a -> IO (a, b)) -> IO (Maybe b)
tryModifyMVarNonAtomically mv f = tryTakeMVar mv >>= \case
  Nothing -> return Nothing
  Just a -> do
    (a', b) <- f a `onException` putMVar mv a
    putMVar mv a'
    return (Just b)

tryModifyMVarNonAtomically_ :: MVar a -> (a -> IO a) -> IO (Maybe ())
tryModifyMVarNonAtomically_ mv f =
  tryModifyMVarNonAtomically mv (fmap (,()) . f)

--withMVarNonAtomically :: MVar a -> (a -> IO b) -> IO b
--withMVarNonAtomically mv f =
--  modifyMVarNonAtomically mv (\a -> do b <- f a; return (a, b))

data Context = Context
  { submissionLimit :: QSem
  , inflightSubmissions :: InflightSubmissions
  , taskCount :: TaskCount
  , serverAlive :: IORef Bool  -- ^ Whether Aquila JobManager is unreachable.
                               --   Detected by runLivenessCheck, also
                               --   settable remotely with disableSubmission
                               --   and reenableSubmission API calls.
  , acceptingConnections :: IORef Bool -- ^ Whether to respond to pings, i.e.
                                       --   declaring that making a connection
                                       --   is permitted.
  }

mkContext :: Options -> IO Context
mkContext opts@Options{..} = do
  submissionLimit <- newQSem maxSubmissions
  inflightSubmissions <- newInflightSubmissions
  taskCount <- io $ newTaskCount opts
  serverAlive <- newIORef =<< maybe (return True)
                                    (io . fmap isRight . JobManager.ping)
                                    aquilaJobMan
  acceptingConnections <- newIORef True
  return Context {..}

submitJob :: Options -> Context -> SubmitJob -> IO InflightJobHandle
submitJob opts Context{..} job@SubmitJob{..} = do
  tc <- io $ gridTaskCount taskCount
  putStrTs $ "Grid pending task counts" & if R.size tc == 0 then ": 0"
                                          else "\n"&show tc
  local <- if jobNTasks <= smallLimit opts
              && isJust (onPremJobMan opts) && isJust (onPremTrail opts)
           then do
               alive <- fmap isRight
                        $ (io $ JobManager.ping (fromJust $ onPremJobMan opts))
                          `catch` (\s-> return (Left s))
               putStrTs $ "On-prem liveness (fetched): " & show alive
               if alive then flip catch (\_-> return False) $ do
                 onPremCapacity <- io $ currentOnPremCapacity
                                      $ fromJust $ onPremTrail opts
                 return (jobNTasks <= onPremCapacity)
               else return False
           else return False
  when (not local) $ do
      alive <- readIORef serverAlive
      putStrTs $ "Server liveness (cached): " & show alive
      when (not alive) $ do
          printThenFail $ "submitJob rejected: server offline "
                        & fromMaybe "unknown" (fmap show (aquilaJobMan opts)
                                              <|> multiAquilaDBName opts)
  let opts' = if local then opts{aquilaJobMan=onPremJobMan opts} else opts
  waitQSem submissionLimit
  inflight <- doSubmit opts' tc `onException` signalQSem submissionLimit
  hdl <- InflightJobHandle <$> io Core.createGuid
  addJob inflightSubmissions hdl inflight
  putStrTs $ unwords [ "submitJob:", unInflightJobHandle hdl ]
  return hdl
  where
  doSubmit opts tc = do
    distOpt <- case version jobStrategy of
        Nothing -> return []
        Just ver -> do
            dd <- io $ binDir ver
            return [dist ver dd]
    jobCollector <- fmap Left $ mkCollector distOpt
    lastSeen <- io Date.now
    return InflightJob {..}
    where
    mkCollector procOpts = computeIO procOpts $ do
        () <- return ()
        f <- bgImportFunctionDeferred "Cortex.Risk.Broker.Async.CheckAndSubmit.checkAndSubmit"
        f opts tc job

collectResults :: Context
               -> InflightJobHandle
               -> IO (Maybe (Dict Int (Object IByteString)))
collectResults Context{..} hdl =
  lookupJob inflightSubmissions hdl >>= maybe (noSuchJob hdl) collectUpdate
  where
  collectUpdate = flip modifyMVarNonAtomically
    $ maybe (noSuchJob hdl) collectUpdate'
  collectUpdate' job =
    either (collectFut job) (collectNow job) (jobCollector job)
  collectNow job collector = do
    -- if collect fails broker client calls 'close' to  cleanup
    ts <- io Date.now
    (Just job { lastSeen = ts },) <$> collect collector
  collectFut job colFuture =
    try (io (result colFuture 5)) >>= either submitFailed (submitNotFailed job)
  submitFailed err = do
    putStrTs $ unwords [ "submission failure:", err ]
    putStrTs $ unwords [ "submitFailed removeJob:", unInflightJobHandle hdl ]
    removeJob inflightSubmissions hdl
    -- QR checks/submission failed, signal the QSem
    signalQSem submissionLimit
    fail err
  submitNotFailed job = maybe (colletorNotReady job) (collectorReady job)
  colletorNotReady job = do
    -- QR checks/submission has not finished yet, keep waiting
    ts <- io Date.now
    return (Just job { lastSeen = ts }, Just Dict.empty)
  collectorReady job collector = do
    -- QR checks/submission has finished, signal the QSem
    signalQSem submissionLimit
    ts <- io Date.now
    let updated = job { lastSeen = ts
                      , jobCollector = Right collector }
    (Just updated,) <$> collect collector

closeInflight :: Context -> InflightJobHandle -> IO ()
closeInflight ctx@Context{..} hdl =
  lookupJob inflightSubmissions hdl >>= maybe (noSuchJob hdl) closeIt
  where
  closeIt job = modifyMVarNonAtomically_ job $ maybe (noSuchJob hdl) closeJob
  closeJob InflightJob{..} = do
    either (closeFut ctx hdl) (closeCollector ctx hdl) jobCollector
    return Nothing

pingVersion :: Context -> IO Version.Version
pingVersion _ctx = do
    v <- io Core.versionLong
    return $ fromMaybe dummy (Version.parseVersion v)
  where
    dummy = Version.Version
                { versionDate     = Date.date 1900 01 01
                , versionSuffix   = "s000000"
                , versionCompiler = "(unreal)"
                }

runHouseKeeping :: Options -> Context -> IO ()
runHouseKeeping Options{..} ctx@Context{..} =
  void $ forkIO $ forever $ try $ do
    threadDelay (60 * 1000 * 1000)
    jobs <- listJobs inflightSubmissions
    putStrTs $ unwords ["Housekeeping", show (length jobs), "jobs"]
    forM_ jobs $ \(hdl, job) -> tryModifyMVarNonAtomically_ job $ \case
      Nothing -> do
        removeJob inflightSubmissions hdl
        return Nothing -- job is already closed/expired
      Just job -> houseKeep hdl job
    where
    houseKeep hdl job@InflightJob{..} = do
      ts <- io Date.now
      if Date.diffTime ts lastSeen >= expiryLimit
      then do
        putStrTs $ unwords
            [ "Expiring job", unInflightJobHandle hdl
            , "now is", show ts
            , "last seen", show lastSeen ]
        either (closeFut ctx hdl) (expireCollector ctx hdl) jobCollector
        return Nothing
      else
        return (Just job)

runLivenessCheck :: Options -> Context -> IO ()
runLivenessCheck Options{..} Context{..} =
  void $ forkIO $ forever $ try $ do
    threadDelay (5 * 60 * 1000 * 1000)
    alive <- readIORef serverAlive
    x <- maybe (return True)
               (io . fmap isRight . JobManager.ping)
               aquilaJobMan
    case x of
        False -> do let failed = if alive then "failed:" else "failed again:"
                    putStrTs $ unwords [ "Liveness check"
                                       , failed
                                       , show aquilaJobMan ]
                    atomicModifyIORef_ serverAlive (const False)
        True  -> when (not alive) $ do
                    putStrTs $ unwords [ "Liveness check re-succeeded:"
                                       , show aquilaJobMan ]
                    atomicModifyIORef_ serverAlive (const True)

closeFut :: Context -> InflightJobHandle -> Future AsyncCollector -> IO ()
closeFut Context{..} hdl colFut = try (abort colFut) >>= \case
  Left e -> putStrTs $ unwords ["failed to abort submission", e]
  Right _ -> do
    putStrTs $ unwords [ "closeFut removeJob:", unInflightJobHandle hdl ]
    removeJob inflightSubmissions hdl
    signalQSem submissionLimit

closeCollector :: Context -> InflightJobHandle -> AsyncCollector -> IO ()
closeCollector Context{..} hdl collector = do
  void $ try (close collector)
  putStrTs $ unwords ["closeCollector removeJob:", unInflightJobHandle hdl]
  removeJob inflightSubmissions hdl

expireCollector :: Context -> InflightJobHandle -> AsyncCollector -> IO ()
expireCollector Context{..} hdl _ = do
  -- just remove the collector from the map and let the far-end times it out
  putStrTs $ unwords ["expireCollector removeJob:", unInflightJobHandle hdl]
  removeJob inflightSubmissions hdl

noSuchJob :: InflightJobHandle -> IO a
noSuchJob hdl = fail $ unwords
  [ "failed to find job handle", unInflightJobHandle hdl ]

currentOnPremCapacity :: (String,Int) -> SafeIO Int
currentOnPremCapacity (host,port) = do
    to <- Date.now
    let from = to Time.$- ( 10 * Time.oneSecond )
    conn <- Trail.connect host port
    xs <- Trail.queryLoad conn (Trail.LoadQuery Trail.TaskCount 5
                                                Trail.UnGrouped from to)
    is <- Trail.queryInstanceInventory conn from to
    let maxCapacity = (\z-> if null z then 0 else snd (last z))
                    $ Trail.capacitySeries from to
                    $ R.extract (:: R.LabelsOf '[ Trail.CNumberOfCores
                                                , Trail.CInstanceStarted
                                                , Trail.CInstanceStopped ])
                                (:: R.Sorting '[]) is
    let maxRunning  | null xs   = 0
                    | otherwise = let z = head [ running | (_,_,running) <- xs ]
                                  in if null z then 0 else snd (last z)
    return $ truncate $ maxCapacity - maxRunning
