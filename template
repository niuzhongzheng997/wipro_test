{-|
This is Aquila Worker.

For more details on Aquila see "Cortex.Concurrent.Aquila"
-}
{-# LANGUAGE RecordWildCards #-}
module Cortex.Concurrent.Aquila.Worker(
    main
) where

import Control.Alternative((<|>))
import Control.Concurrent
import Control.Concurrent.MVar
import Control.Monad
import Control.Exception
import Data.Default
import Data.Maybe(isNothing)
import System.Console.CmdArgs.Explicit

import Cortex.Concurrent.Aquila.InstanceManager.Types
import Cortex.Concurrent.Aquila.Types
import Cortex.Concurrent.Aquila.Utils
import Cortex.Data.HTTP.Persistent
import Cortex.Data.HTTP.Server
import Cortex.Stem.Core.ProcInfo
import qualified Cortex.Concurrent.Aquila.InstanceManager.Client as InstanceManager
import qualified Cortex.Stem.Core as Core
import qualified Cortex.Stem.Fun as Fun
import qualified Cortex.Stem.Stream.Mu as Stream
import qualified Cortex.Stem.Thread.Mu as Thread

data WorkerOptions = WorkerOptions
    { worker_id           :: WorkerId
    , worker_instancePort :: InstancePort
    , worker_debug        :: Debug
    , worker_jobId        :: JobId
    , worker_jobAddr      :: JobHost
    , worker_jobPort      :: JobPort
    , worker_memLimit     :: Maybe Double
    } deriving (Show)

instance Default WorkerOptions where
    def = WorkerOptions
            { worker_id = WorkerId "no-worker"
            , worker_instancePort = InstancePort 32200
            , worker_debug = DebugNormal
            , worker_jobId = JobId "none"
            , worker_jobAddr = JobHost "127.0.0.1"
            , worker_jobPort = JobPort 32001
            , worker_memLimit = Nothing }

serverConfig :: Config
serverConfig = def
    { title = __MODULE__
    , nThreads = 8
    , port = 32210
    , reuseAddr = False
    , safe = False
    , core = POCO
    }

main :: IO ()
main = serverMain start "Worker" serverConfig
    [flagReq ["worker-id"] (\s x -> Right ( x { worker_id = WorkerId s }))
        "STRING" "Worker id"
    ,flagReq ["instance-port"] (\s x -> Right ( x { worker_instancePort=read s } ))
        "PORT" "Port number of Instance manager"
    ,flagReq ["debug"] (\s x -> Right ( x { worker_debug = read s } ))
        "DEBUG" "Debug level"
    ,flagReq ["job-id"] (\s x -> Right ( x { worker_jobId=JobId s } ))
        "STRING" "Job id"
    ,flagReq ["job-host"] (\s x -> Right ( x { worker_jobAddr=JobHost s } ))
        "HOST" "Hostname/IP of Job manager"
    ,flagReq ["job-port"] (\s x -> Right ( x { worker_jobPort=read s } ))
        "PORT" "Port number of Job manager"
    ,flagReq ["memory-limit"] (\s x -> Right (x{worker_memLimit=Just (read s)}))
        "DOUBLE" "Worker process exits if memory usage exceeds this number when not processing tasks"
    ]

start :: Config -> WorkerOptions -> IO Server
start cfg opts@WorkerOptions{..} = runServer cfg =<< do

    exitSignal <- newEmptyMVar

    -- main work thread
    forkIO $ do
        handle <- io clientHandle
        tryWithMsg
            $ flip loopM (Nothing, Nothing) $ uncurry
            $ processTask exitSignal cfg opts handle
        -- if above throws, e.g. bad_alloc, exit
        void $ tryPutMVar exitSignal 1

    -- job status monitoring
    forkIO $ do
        handle <- io clientHandle
        forever $ do
            statusMonitor exitSignal cfg opts handle
            io $ Thread.sleep 30

    forkIO $ do
        tryWithMsg (takeMVar exitSignal >>= Core.exit)
        -- if above throws, e.g. bad_alloc, just exit
        Core.exit 1

    return $ do
        "ping" $/ GET $. \r -> responseText "pong"
        "exit" $/ GET $. \r -> do
            putStrLn "Exit requested"
            forkIO $ do
                io $ Thread.sleep 5
                Core.exit 0
            return $ responseText "OK"

statusMonitor exitSignal cfg WorkerOptions{..} handle = do
    backoff True 2 2.0 10.0
        (InstanceManager.isJobValid handle worker_instancePort worker_jobId)
      >>= either (gotError exitSignal worker_id workerPort worker_jobId)
                 (gotStatus)
    where
    workerPort = WorkerPort $ port cfg
    gotStatus b = unless b $ do
        putStrTs $ unwords
            [ "jobid", unJobId worker_jobId
            , "worker", unWorkerId worker_id
            , "on port", show workerPort
            , "failed to verify job status" ]
        void $ tryPutMVar exitSignal 1

processTask exitSignal cfg WorkerOptions{..} handle closure prev = do
    let needClosure = isNothing closure
        prevResult = fmap f prev where
            f (tid, info, r) = (tid, (info, WrappedResult $ Stream.streamValueByteString r))
        workRequest = timeIt (worker_debug >= DebugNormal)
                             (unwords
                                [ "jobid", unJobId worker_jobId
                                , "worker", unWorkerId worker_id
                                , "on port", show workerPort
                                , "task request" ])
            $ do
                requestNewTask <- case worker_memLimit of
                    Nothing -> return True
                    Just limit -> do
                        usage <- io Core.peakUsage
                        if usage > limit
                        then do
                            putStrTs $ unwords
                                [ "jobid", unJobId worker_jobId
                                , "worker", unWorkerId worker_id
                                , "on port", show workerPort
                                , "peak memory usage", show usage
                                , "exceeds limit", show limit ]
                            return False
                        else do
                            putStrTs $ unwords
                                [ "jobid", unJobId worker_jobId
                                , "worker", unWorkerId worker_id
                                , "on port", show workerPort
                                , "peak memory usage", show usage
                                , "within limit", show limit ]
                            return True
                InstanceManager.work
                    worker_id
                    handle worker_instancePort
                    worker_jobAddr worker_jobPort worker_jobId workerPort
                    WorkerRequest {..}
    when (worker_debug >= DebugLoud) $ putStrTs $ unwords
            [ "jobid", unJobId worker_jobId
            , "worker", unWorkerId worker_id
            , "on port", show workerPort
            , "is getting task"
            , if needClosure then "and closure" else "" ]
    try workRequest
        >>= either (gotError exitSignal worker_id workerPort worker_jobId)
                   (gotWork closure)
    where
    workerPort = WorkerPort $ port cfg
    gotWork _ (Nothing, _) = do
        putStrTs $ unwords
            [ "jobid", unJobId worker_jobId
            , "worker", unWorkerId worker_id
            , "on port", show workerPort
            , "found no work" ]
        tryPutMVar exitSignal 0
        return $ Right ()
    gotWork closure (Just (tid, arg), closure') = do
        when (worker_debug >= DebugNormal) $ putStrTs $ unwords
            [ "jobid", unJobId worker_jobId
            , "worker", unWorkerId worker_id
            , "on port", show workerPort
            , "now runs task", show tid ]
        cls <- case closure' <|> closure of
            Nothing -> do
                tryPutMVar exitSignal 1
                fail $ unwords
                    [ "jobid", unJobId worker_jobId
                    , "worker", unWorkerId worker_id
                    , "on port", show workerPort
                    , "found no closure" ]
            Just cls -> return cls
        let (res, info) = evalWithInfo
                            Nothing
                            (Fun.try1 (Core.applyAny cls))
                            arg
        return $ Left (Just cls, Just (tid, info, res))

gotError exitSignal worker_id workerPort worker_jobId err = do
    tryPutMVar exitSignal 1
    fail $ unwords
        [ "jobid", unJobId worker_jobId
        , "worker", unWorkerId worker_id
        , "on port", show workerPort, "failed:", err ]
