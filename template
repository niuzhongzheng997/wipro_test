{-|
This is Aquila Grid Manager.

For more details on Aquila see "Cortex.Concurrent.Aquila"
-}
{-# LANGUAGE LambdaCase, RecordWildCards #-}
module Cortex.Concurrent.Aquila.Manager
    ( main
    , jobStarted, jobProgress, jobFinished, jobAlloc
    , ManagerOptions(..), start, serverConfig, flags
    ) where

import Control.Concurrent
import Control.Concurrent.MVar
import Control.Exception
import Control.Monad
import Data.Default
import Data.List(sortBy, sortNub)
import Data.Ord(comparing)
import Data.Traversable(traverse)
import System.Console.CmdArgs.Explicit

import Cortex.Concurrent.Aquila.Manager.JobAllocation as JA
import Cortex.Concurrent.Aquila.Types
import Cortex.Concurrent.Aquila.Utils
import Cortex.Data.HTTP.Persistent
import Cortex.Data.HTTP.Server as Server
import Cortex.Data.String.Mu(sipFormat)
import qualified Cortex.Data.String.Mu as Str
import qualified Cortex.Stem.Core as Core
import qualified Cortex.Stem.Thread.Mu as Thread
import qualified Cortex.Temporal.Date as Date
import qualified Cortex.Concurrent.Aquila.DistManager.Client as DistManager
import qualified Cortex.Concurrent.Aquila.Trail.Client as Trail

-- Manager options
data ManagerOptions = ManagerOptions
    { distManager     :: Maybe (String, Int)
    , trail           :: Maybe (String, Int)
    , debug           :: Debug
    } deriving (Show)

instance Default ManagerOptions where
    def = ManagerOptions
        { distManager = Just ("localhost", 31998)
        , trail = Nothing
        , debug = DebugNormal
        }

serverConfig :: Server.Config
serverConfig = def
    { title = __MODULE__
    , nThreads = 1024
    , maxQueued = Just 1024
    , port = 31999
    , reuseAddr = False
    , safe = False
    , core = POCO
    , keepAliveConfig = Nothing
    }

flags :: [Flag ManagerOptions]
flags =
    [ flagReq ["dist-manager"] (\s x -> Right(x{distManager=Just(hostPortPair s)}))
        "HOST:PORT" "Aquila dist manager host:port"
    , flagReq ["trail"] (\s x -> Right ( x { trail = Just $ hostPortPair s}))
        "HOST:PORT" "Aquila Trail host:port"
    , flagReq ["debug"]             (\s x -> Right (x { debug = read s } ))
        "DEBUG" "Debug level"
    ]

main :: IO ()
main = serverMain start "Aquila Manager" serverConfig flags

start :: Server.Config -> ManagerOptions -> IO Server
start cfg ManagerOptions{..} = runServer cfg =<< do

    -- Contact the Dist server if specified
    versions <- newMVar . pure . CortexVersion =<< io Core.version

    distMan <- io clientHandle

    let checkVers = do
          supportedVers <- case distManager of
              Just (addr, port) -> fmap (either (const []) id)
                  $ try $ DistManager.available distMan addr port
              otherwise -> return []
          modifyMVar_ versions $ \vers -> do
              let vers' | not (null supportedVers) = sortNub supportedVers
                        | otherwise = vers
              when (vers /= vers') $ putStrTs $ unwords
                  [ "Supported versions:"
                  , Str.intercalate ", " $ map unCortexVersion vers' ]
              return vers'

    checkVers

    trailConn <- io $ traverse (uncurry Trail.connect) trail

    -- Needs to be a list so that we can round-robin across calls to get jobs
    jobAllocator <- JA.newJobAllocator 5 Nothing

    let expireJobs = do
            expired <- JA.jobExpired jobAllocator
            unless (null expired) $ putStrTs $ unwords
                [ "expired", show $ map unJobId expired ]
            ts <- io Date.now
            whenJust trailConn $ \trail -> forM_  expired $ \jobId -> do
                let purge = Trail.finishJob trail (unJobId jobId)
                          $ Trail.JobPerf ts (Just "job purged")
                backoff False 3 1 10 purge >>= \case
                    Left e -> putStrTs e
                    Right () -> return ()

    -- Keep supported versions up to date
    forkIO $ forever $ do
        tryWithMsg checkVers
        tryWithMsg expireJobs
        io $ Thread.sleep 60

    return $ do

        "jobStarted" $/ postValue
                     $ \r job@Job{job_metadata=JobMetadata{..},..} ->
          do
            vers <- readMVar versions
            if job_version `elem` vers
            then do
                JA.jobProgress jobAllocator job
                when (debug >= DebugNormal) $ putStrTs $ unwords
                    [ "started"
                    , show ( job_user, job_id, job_version
                           , job_addr, job_port
                           , job_session, job_ntodo
                           , sipFormat job_largestTaskMem 0) ]
                return $ responseObject
                       $ toAny (Nothing :: Maybe String)
            else
                return $ responseObject
                       $ toAny (Just $ unwords [ "Version"
                                               , unCortexVersion job_version
                                               , "is not supported" ])

        "jobProgress" $/ postValue
          $ \r job@Job{job_progress=p@JobProgress{..}, ..} -> do
            now <- io Date.now -- use local time to avoid clock skew
            JA.jobProgress jobAllocator job{job_progress=p{job_lastSeen=now}}
            when (debug >= DebugLoud) $ putStrTs $ unwords
                [ "jobid", unJobId (job_id job_metadata)
                , show (job_available, job_complete, job_allocated) ]
            return $ responseObject $ toAny ()

        "jobFinished" $/ GET $. \r ->
            case r ?& "jobid" of
                Just jid -> do
                    JA.jobFinish jobAllocator (JobId jid)
                    when (debug >= DebugNormal) $
                        putStrTs $ unwords [ "finished", jid ]
                    return $ responseObject $ toAny ()
                _ -> printThenFail "jobFinished: missing jobid parameter"

        "jobAlloc" $/ postValue $ \r allocRequest -> do
            -- putStrTs $ "jobAlloc" & show allocRequest
            now <- io Date.now
            allocated <- JA.jobAllocations jobAllocator now allocRequest

            when (DebugNormal <= debug && debug < DebugLoud
                && not (null allocated))
                $ putStrTs $ unwords
                    [ "requested", show (freeWorkers allocRequest)
                    , "allocated", show (length allocated), "tasks"
                    , show $ map (\(_, AllocatedJob{..}) ->
                                    ( aj_jobId
                                    , aj_jobVersion
                                    , aj_jobPort
                                    , sipFormat (aj_jobMaxTaskMem) 0))
                                 (sortNub allocated) ]
            when (debug >= DebugLoud)
                $ putStrTs $ unwords
                    [ "requested", show allocRequest
                    , "allocated", show (length allocated), "tasks"
                    , show $ sortNub allocated ]

            return $ responseObject $ toAny allocated

--
-- Job Info
--
        "jobs" $/ GET $. \r -> do
            -- FIXME: The list is volatile, sort it first
            info <- sortBy (comparing $ job_session . job_metadata)
                 <$> JA.jobInfo jobAllocator
            return $ responseText $ unlines $
                ["Jobs : allocated - complete / available"
                ,"---------------------------------------"
                ] ++
                (map (\Job { job_progress=JobProgress{..}
                           , job_metadata=JobMetadata{..}
                           , ..} -> unwords
                        [ job_user, job_session, unJobId job_id
                        , unCortexVersion job_version
                        , unJobHost job_addr & ":" & show job_port
                        , ":"
                        , show job_allocated, "-", show job_complete
                        , "/", show job_available
                        ])
                     info)

        "exit" $/ GET $. \r -> do
            Core.exit 0
            return $ responseText "OK"

----------------------------------------------------------------

-- Manager client API

opts = noproxy
    |+| TimeOut (5 * 60)
    |+| KeepAlive False

jobStarted :: HTTPClient -> (ManagerHost, ManagerPort) -> Job -> IO (Maybe String)
jobStarted handle (host, port) job = post handle url job [] opts
    where url = mconcat [ "http://", unManagerHost host, ":", show port
                        , "/jobStarted" ]

jobProgress :: HTTPClient -> (ManagerHost, ManagerPort) -> Job -> IO ()
jobProgress handle (host, port) job = post handle url job [] opts
    where url = mconcat [ "http://", unManagerHost host, ":", show port
                        , "/jobProgress"]

jobFinished :: HTTPClient -> (ManagerHost, ManagerPort) -> JobId -> IO ()
jobFinished handle (host, port) jobId = get handle url [] opts
    where url = mconcat [ "http://", unManagerHost host, ":", show port
                        , "/jobFinished?jobid=", unJobId jobId ]

jobAlloc
    :: HTTPClient
    -> (ManagerHost, ManagerPort)   -- ^ server:
    -> AllocationRequest -- ^ alloc request
    -> IO [(Int, AllocatedJob)] -- ^ allocated jobs
jobAlloc handle (host, port) alloc = post handle url alloc [] opts
    where url = mconcat [ "http://", unManagerHost host, ":", show port
                        , "/jobAlloc" ]
