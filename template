{-|
This is Aquila Instance Manager.

For more details on Aquila see "Cortex.Concurrent.Aquila"
-}
{-# LANGUAGE LambdaCase, RecordWildCards #-}
module Cortex.Concurrent.Aquila.InstanceManager
    ( main
    , InstanceOptions(..), serverConfig, flags, start
    ) where

import Control.Monad
import Control.Concurrent
import Control.Exception
import Data.Maybe(isJust, isNothing)
import System.Console.CmdArgs.Explicit

import Cortex.Data.HTTP.Server
import Cortex.Data.HTTP.Server.Config
import Cortex.Concurrent.Aquila.InstanceManager.Internal
import Cortex.Concurrent.Aquila.InstanceManager.Types
import Cortex.Concurrent.Aquila.Types
import Cortex.Concurrent.Aquila.Utils
import Cortex.Temporal.Date.Mu(now, readDatetimeWithFormat)
import qualified Cortex.Concurrent.Aquila.InstanceManager.JobDataManager as JDM
import qualified Cortex.Concurrent.Aquila.Trail.Client as Trail
import qualified Cortex.Concurrent.Aquila.Trail.Utils as Trail
import qualified Cortex.Data.HTTP.Mu as HTTP
import qualified Cortex.Stem.Core as Core
import qualified Cortex.Stem.Thread.Mu as Thread

serverConfig :: Config
serverConfig = def
    { title = __MODULE__
    , nThreads = 1024
    , backlog = Just 1024
    , maxQueued = Just 1024
    , port = 32200
    , reuseAddr = False
    , safe = False
    , core = POCO
    , keepAliveConfig = Just KeepAlive
        { keepAliveTimeout = 1 * 60 -- 1 minute
        , keepAliveRequests = 0     -- infinity
        }
    }

flags :: [Flag InstanceOptions]
flags =
    [ flagReq ["dists"] (\s x -> Right (x { distsDir = Just s} ))
        "PATH" "Path to Cortex distribution archives"
    , flagReq ["install-dir"] (\s x -> Right (x { installDir = Just s} ))
        "PATH" "Directory to install Cortex dists"
    , flagReq ["slots"] (\s x -> Right (x { nWorkers = read s} ))
        "INT" "Number of workers on this instance"
    , flagReq ["min-free-memory"] (\s x -> Right x{minFreeMem=read s})
        "DOUBLE" "Minimum number of free bytes to send job allocation request"
    , flagReq ["memory-limit"] (\s x -> Right x{memoryLimit=Just (read s)})
        "DOUBLE" "At-rest memory limit for workers"
    , flagReq ["max-lifetime"] (\s x -> Right (x { maxLifetime = read s } ))
        "DOUBLE" "Max lifetime in seconds. 0 for spot, n*3600 for n-hour spot block. Default to infinity."
    , flagReq ["wait"] (\s x -> Right (x { messageWait = fromInt $ read s} ))
        "INT" "Number of seconds to wait between messages to job manager"
    , flagReq ["debug"] (\s x -> Right ( x { debugLevel = read s } ))
        "DEBUG" "Debug level"
    , flagReq ["manager"] (\s x -> Right (x { manager = parseManager s} ))
        "HOST:PORT" "grid manager host:port"
    , flagReq ["dist-manager"] (\s x -> Right (x { distManager = hp' s }))
        "HOST:PORT" "dist manager host:port"
    , flagReq ["trail"] (\s x -> Right (x { trail = hp' s }))
        "HOST:PORT" "trail host:port"
    , flagReq ["lot-id"] (\s x -> Right (x{lotId=s}))
        "STRING" "unique identifier to relate to cloud order id"
    ]
    where
    hp' = Just . hostPortPair

main :: IO ()
main = serverMain start "InstanceManager" serverConfig flags

checkArgs InstanceOptions{..} = do
    when (isJust distsDir && isNothing installDir) $
        fail "install-dir must be set if dists-dir is set"

    when (isJust distManager && not (isJust distsDir && isJust installDir)) $
        fail "dists-dir and install-dir must be set if a dist-manager is used"

updateTrail instanceState lotId h p = do
    conn <- io $ Trail.connect h p
    (inst, usage) <- io $ Trail.mkInstanceInfo lotId
    myIPAddress <- io Core.getIPAddress

    tryWithMsg $ Trail.startInstance conn myIPAddress inst

    void $ forkIO $ flip loopM (usage, []) $ \(usage, perfs) -> do
        io $ Thread.sleep 5
        tryWithMsg $ preemptCheck conn myIPAddress
        updatePerf conn myIPAddress usage perfs

    where

    preemptCheck conn myIPAddr
        = either (const $ return ()) term =<< getTerminationNotice =<< io now
        where
        getTerminationNotice now = do -- FIXME take a vendor parameter for this
            r <- try $ io $ HTTP.http_
                [] HTTP.GET
                "http://169.254.169.254/latest/meta-data/spot/termination-time"
                ""
            return $ case r of
                Left e -> Left e
                Right r -> case HTTP.responseCode r of
                    200 -> Right $ readTime $ HTTP.responseBody r
                    x -> Left $ unwords ["got error code", show x]
            where
            readTime = either (const now) id
                     . readDatetimeWithFormat (Just "yyyy-mm-ddThh:nn:ssZ")
        -- TODO update job manager
        term = tryWithMsg . stopInstance conn myIPAddr
        stopInstance conn myIPAddr instanceStopped = tryWithMsg
            $ Trail.stopInstance conn myIPAddr
                Trail.InstanceStop { termination = Trail.Terminated, ..}

    updatePerf conn myIPAddress usage perfs = do
        actives <- activeWorkers instanceState
        (perf, usage) <- io $ Trail.mkInstancePerf actives usage
        let perfs' = perf:perfs
        if length perfs' > 30 `div` 5
        then do
            tryWithMsg $ Trail.updateInstance conn
                       $ map (myIPAddress,) perfs'
            return $ Left (usage, [])
        else
            return $ Left (usage, perfs')

{-
checkInstanceMemory inst = do
    avail <- instanceAvailMem inst
    reserved <- instanceReservedMem inst
    let total = instanceTotalMem inst
    putStrTs $ unwords [ "instance memory:", show ( sipFormat total 0
                                                  , sipFormat reserved 0
                                                  , sipFormat avail 0 ) ]
    when (avail < 0) $ do
        putStrTs "available memory is negative. Exiting..."
        Core.exit 1
{-
    when (abs (reserved + avail - total) > 0.05 * total) $ do
        -- allowing some margin for accumulated arithmetic errors ...
        putStrTs "reserved plus avail exceeding total memory. Exiting..."
        Core.exit 2
-}

-}

start :: Config -> InstanceOptions -> IO Server
start cfg instOpts@InstanceOptions{..} = runServer cfg =<< do

    checkArgs instOpts

    instanceState <- newInstance cfg instOpts
    let instanceManagerId = instanceId instanceState
        jdmPort = jdmParent instanceState
        jdmOpts = (JDM.defJDMConfig jdmPort nJDMs)
            { JDM.instanceManagerId = instanceManagerId
            , JDM.instanceManagerPort = InstancePort (port cfg) }

        startJDM = do
            putStrTs $ unwords
                [ "Start JDM on", show (unJobDataManagerPort jdmPort)
                , "for", unInstanceManagerId instanceManagerId ]
            waitForServer =<< JDM.start jdmOpts

    putStrTs $ unwords
        [ "InstMan starting on port", show (port cfg)
        , "with instance id", unInstanceManagerId instanceManagerId
        , "with JDM on", show (unJobDataManagerPort jdmPort) ]

    -- Start JobDataManager and keep it running
    forkIO $ crashRecover 60 startJDM

    forkIO $ forever $ try (masterControl instanceState) >>= \case
        Left e -> do
            putStrTs $ unwords ["exception in master control thread:", e ]
            putStrTs "exiting"
            Core.exit 1
        Right _ -> do
            io $ Thread.sleep 5
            return ()

    -- thread to keep Trail updated
    whenJust trail . uncurry $ updateTrail instanceState lotId

    return $ do
        "work" $/ postValue $ \r request ->
            case (r ?& "jobhost", r ?& "jobport", r ?& "jobid", r ?& "workerid", r ?& "workerport") of
                (Just jobHost, Just jobPort, Just jobId, Just workerId, Just workerPort) ->
                    responseObject . toAny
                        <$> workerRequest
                                instanceState
                                (JobHost jobHost) (read jobPort) (JobId jobId)
                                (WorkerId workerId) (read workerPort) request
                otherwise -> printThenFail $ unwords
                        [ "work: missing required parameters." ]

        "imid" $/ GET $. \r -> case r ?& "imid" of
            Just imid -> if InstanceManagerId imid == instanceManagerId
                then return . responseObject $ toAny ()
                else printThenFail $ unwords
                    [ "imid: expecting imid", unInstanceManagerId instanceManagerId
                    , "got", imid ]
            Nothing -> printThenFail $ unwords
                    [ "imid: expecting imid", unInstanceManagerId instanceManagerId
                    , "got Nothing"]

        "isjobvalid" $/ GET $. \r -> case r ?& "jobid" of
            Just jobId -> return . responseObject . toAny
                                =<< isJobValid instanceState (JobId jobId)
            Nothing -> printThenFail "isjobvalid: missing jobid parameter"

        "exit" $/ GET $. \r -> do
            Core.exit 0
            return $ responseText "OK"
