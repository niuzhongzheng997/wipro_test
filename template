{-|
This is Aquila Dist Manager.

For more details on Aquila see "Cortex.Concurrent.Aquila"
-}
module Cortex.Concurrent.Aquila.DistManager
    ( main
    , DistManagerOptions(..), start, serverConfig, flags
    ) where

import Control.Concurrent.QSem

import Cortex.Data.HTTP.Server as Server
import Cortex.Data.Regex as Regex
import Cortex.Stem.Thread.Mu as Thread
import qualified Cortex.Stem.Core as Core

import System.Directory as Dir
import System.Console.CmdArgs.Explicit

import Control.Monad
import Control.Concurrent
import Control.Concurrent.MVar
import Data.Default
import qualified Cortex.Data.Version as Version
import qualified Cortex.Data.String.Mu as Str
import qualified Cortex.Temporal.Date as Date

import Cortex.Data.JSON.Mu

data DistManagerOptions = DistManagerOptions
    { distManager_cortexDists :: String
    , maxConcurrentDownloads :: Int
    } deriving (Show)


instance Default DistManagerOptions where
    def = DistManagerOptions
        { distManager_cortexDists = "./"
        , maxConcurrentDownloads = 30
        }

serverConfig :: Server.Config
serverConfig = def
    { title = __MODULE__
    , nThreads = 1024
    , backlog = Just 1024
    , maxQueued = Just 1024
    , port = 31998
    , reuseAddr = False
    , safe = False
    , core = POCO
    , keepAliveConfig = Nothing
    }

flags :: [Flag DistManagerOptions]
flags =
    [ flagReq ["dists"]
        (\s x -> Right (x {distManager_cortexDists=s}))
        "PATH" "Path to Cortex distribution archives"
    , flagReq ["max-downloads"]
        (\s x -> Right (x {maxConcurrentDownloads= read s}))
        "INT" "Max concurrent downloads"
    ]

main :: IO ()
main = serverMain start "DistManager" serverConfig flags

start :: Server.Config -> DistManagerOptions -> IO Server
start cfg opts = runServer cfg =<< do

    let dists_dir = distManager_cortexDists opts

    dists :: MVar [String] <- newMVar []

    -- Search for dists
    let checkDists = do
          dir_exists <- Dir.doesDirectoryExist dists_dir
          dir_files <- if dir_exists
              then Dir.getDirectoryContents dists_dir
              else return []
          let re = Regex.create "(.*)\\.tar\\.gz" -- FIXME "(.*)\\.tar\\.gz$"
              matches = map (\x -> Regex.searchEx re x) dir_files
              matches' = filter (\l -> length l == 2) matches
          modifyMVar_ dists $ \d -> do
              let d' = map (!!1) matches'
              when (d /= d') $ do
                  putStrLn $ "Available distributions: " & Str.intercalate ", " d'
              return d'

    checkDists

    forkIO $ forever $ do
        checkDists
        io $ Thread.sleep 20

    downloadsLimit <- newQSem $ maxConcurrentDownloads opts

    tod <- io Date.today
    return $ do
        "available" $/ GET $. \r ->
            case (r ?& "format") of
                (Just format) | format == "json"
                  -> responseJSON . encode . toJSON <$> readMVar dists
                otherwise
                  -> responseObject . toAny <$> readMVar dists
        "dist" $/ GET $. \r -> withQSem downloadsLimit $
            case (r ?& "version") of
                (Just version) -> do
                    dists' <- readMVar dists
                    if version `elem` dists'
                    then return $ Server.download (dists_dir & "/" & version & ".tar.gz") Nothing
                    else fail $ "Invalid version " & version
                otherwise -> do
                    fail "Invalid arguments"

        "ping" $/ GET $. \_ -> do
            v <- io Core.versionLong
            return $ responseObject
                   $ toAny
                   $ fromMaybe (if "head"`Str.isPrefixOf`v
                                then Version.Version tod (" ("&v&")") ""
                                else Version.Version (Date.date 1900 01 01)
                                                     "s000000" "(unreal)")
                               (Version.parseVersion v)

        "exit" $/ GET $. \r -> do
            Core.exit 0
            return $ responseText "OK"
